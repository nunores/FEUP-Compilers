/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. Parser.jj */
/*@egen*/options {
    LOOKAHEAD = 1;
}

PARSER_BEGIN(Parser)

import java.util.HashMap;

public class Parser/*@bgen(jjtree)*/implements ParserTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected static JJTParserState jjtree = new JJTParserState();

/*@egen*/
    public static HashMap<String, Integer> symbols = new HashMap<String, Integer>();

    public static void main(String[] args) throws ParseException {
      System.out.println("If you see this, probably its working!");
      Parser jvm = new Parser(System.in);
      SimpleNode root = jvm.Program();
      root.dump("");

      //System.out.println("Expression value: " + myCalc.eval(root));
    }
}

PARSER_END(Parser)

SKIP : {
  " " | "\r" | "\t"
}

TOKEN : {
  < INTEGER: (["0"-"9"])+ >
  | < LF: "\n" >
  | < EQ: "=" >
  | < COL: "," >
  | < SEMICOL: ";" >
  | < DOT: "." >
  | < LBRACE: "{" >
  | < RBRACE: "}" >
  | < LPAR: "(" >
  | < RPAR: ")" >
  | < LBRACK: "[" >
  | < RBRACK: "]" >
  | < AND: "&&" >
  | < OR: "||" >
  | < LESS: "<" >
  | < PLUS: "+" >
  | < MINUS: "-" >
  | < MULT: "*" >
  | < DIV: "/" >
  | < PERCENTAGE: "%" >
  | < TRUE: "true" >
  | < FALSE: "false" >
  | < THIS : "this" >
  | < NEW : "new" >
  | < INT: "int" >
  | < INTARRAY: "int[]" >
  | < STRINGARRAY: "String[]" >
  | < BOOLEAN: "boolean" >
  | < NOT: "!" >
  | < IMPORT: "import" >
  | < CLASS: "class" >
  | < EXTENDS: "extends" >
  | < IF: "if" >
  | < VOID: "void" >
  | < ELSE: "else" >
  | < LENGTH: "length" >
  | < MAIN: "main" >
  | < WHILE: "while" >
  | < PUBLIC: "public" >
  | < STATIC: "static" >
  | < STRING: "string" >
  | < RETURN: "return" >
  | < VAR: ["A"-"Z","a"-"z"](["0"-"9","A"-"Z","a"-"z","_"])* >
}

SimpleNode Program(): {/*@bgen(jjtree) Program */
  SimpleNode jjtn000 = new SimpleNode(JJTPROGRAM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Program */
    try {
/*@egen*/
    ImportDeclaration() ClassDeclaration() <EOF>/*@bgen(jjtree)*/
                                                 {
                                                   jjtree.closeNodeScope(jjtn000, true);
                                                   jjtc000 = false;
                                                 }
/*@egen*/ { return jjtn000; }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void ImportDeclaration(): {/*@bgen(jjtree) ImportDeclaration */
  SimpleNode jjtn000 = new SimpleNode(JJTIMPORTDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ImportDeclaration */
    try {
/*@egen*/
    (
        <IMPORT> Identifier()
        (
            <DOT> Identifier()
        )*
        <SEMICOL>
    )*/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void ClassDeclaration(): {/*@bgen(jjtree) ClassDeclaration */
  SimpleNode jjtn000 = new SimpleNode(JJTCLASSDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ClassDeclaration */
    try {
/*@egen*/
    <CLASS> Identifier()
    [
        <EXTENDS> Identifier()
    ]
    <LBRACE>
    (VarDeclaration())*
    (MethodDeclaration())*
    <RBRACE>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void VarDeclaration(): {/*@bgen(jjtree) VarDeclaration */
  SimpleNode jjtn000 = new SimpleNode(JJTVARDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) VarDeclaration */
    try {
/*@egen*/
    Type() Identifier() <SEMICOL>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void MethodDeclaration(): {/*@bgen(jjtree) MethodDeclaration */
  SimpleNode jjtn000 = new SimpleNode(JJTMETHODDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) MethodDeclaration */
    try {
/*@egen*/
    <PUBLIC>
    (
        Type() Identifier()
        <LPAR>
        [
            Type() Identifier()
            (
                <COL> Type() Identifier()
            )*
        ]
        <RPAR>

        <LBRACE>
        (VarDeclaration())*
        (Statement())*
        <RETURN> Expression() <SEMICOL>
        <RBRACE>
    )
    |
    (
        <STATIC> <VOID> <MAIN>
        <LPAR>
        <STRINGARRAY>
        Identifier()
        <RPAR>

        <LBRACE>
        (VarDeclaration())*
        (Statement())*
        <RBRACE>
    )/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Type(): {/*@bgen(jjtree) Type */
  SimpleNode jjtn000 = new SimpleNode(JJTTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Type */
    try {
/*@egen*/
    <INTARRAY>
    | <BOOLEAN>
    | <INT>
    | Identifier()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Statement(): {/*@bgen(jjtree) Statement */
  SimpleNode jjtn000 = new SimpleNode(JJTSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Statement */
    try {
/*@egen*/
    (
        <LBRACE>
        (Statement())*
        <RBRACE>
    )
    |
    (   <IF> <LPAR> Expression() <RPAR> Statement()
        <ELSE> Statement()
    )
    |
    (
        <WHILE> <LPAR> Expression() <RPAR>
        Statement()
    )
    |
    (Expression() <SEMICOL>)
    |
    (Identifier() 
        (
            (<EQ> Expression() <SEMICOL>)
            |
            (<LBRACK> Expression() <RBRACK> <EQ> Expression() <SEMICOL>)
        )
    )/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Expression(): {/*@bgen(jjtree) Expression */
  SimpleNode jjtn000 = new SimpleNode(JJTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Expression */
    try {
/*@egen*/
    (
        IntegerLiteral()
        |
        <TRUE>
        |
        <FALSE>
        |
        Identifier()
        |
        <THIS>
        |
        <NEW> 
        (
            (<INT> <LBRACK> Expression() <RBRACK>)
            |
            (Identifier() <LPAR> <RPAR>)
        )
        |
        (<NOT> Expression())
        |
        (<LPAR> Expression() <RPAR> )
    )
    Expression1()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}


void Expression1() : {/*@bgen(jjtree) Expression1 */
  SimpleNode jjtn000 = new SimpleNode(JJTEXPRESSION1);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Expression1 */
    try {
/*@egen*/
    [
        (
            ( (<AND> | <LESS> | <PLUS> | <MINUS> | <MULT> | <DIV>) Expression() )
            |
            ( (<LBRACK> Expression() <RBRACK>) )
            |
            (
                <DOT>
                (
                    <LENGTH>
                    |
                    (
                        Identifier() <LPAR>
                        [
                            Expression()
                            (<COL> Expression())*
                        ]
                        <RPAR>
                    )
                )
            )
        )
        Expression1()
    ]/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

/*void Expression1(): {}
{
    IntegerLiteral()
    |
    <TRUE>
    |
    <FALSE>
    |
    Identifier()
    |
    <THIS>
    |
    <NEW>
    (
        (<INT> <LBRACK> Expression() <RBRACK>)
        |
        (Identifier() <LPAR> <RPAR>)
    )
    |
    (<NOT> Expression())
    |
    (<LPAR> Expression() <RPAR>)
}


void Expression(): {}
{
    Expression1()
    [
        ((<AND> | <LESS> | <PLUS> | <MINUS> | <MULT> | <DIV>) Expression())
        |
        (<LBRACK> Expression() <RBRACK>)
        |
        <DOT>
        (
            <LENGTH>
            |
            (
                Identifier() <LPAR>
                [
                    Expression()
                    (<COL> Expression())*
                ]
                <RPAR>
            )
        )
    ]
}*/

void Identifier(): {/*@bgen(jjtree) Identifier */
  SimpleNode jjtn000 = new SimpleNode(JJTIDENTIFIER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Identifier */
    try {
/*@egen*/
    <VAR>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void IntegerLiteral(): {/*@bgen(jjtree) IntegerLiteral */
  SimpleNode jjtn000 = new SimpleNode(JJTINTEGERLITERAL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) IntegerLiteral */
    try {
/*@egen*/
    <INTEGER>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}