options {
    LOOKAHEAD = 1;
}

PARSER_BEGIN(Calculator)

import java.util.HashMap;

public class Calculator {
    public static HashMap<String, Integer> symbols = new HashMap<String, Integer>();

    public static void main(String[] args) throws ParseException {
      System.out.println("If you see this, probably its working!");
      Calculator jvm = new Calculator(System.in);
      SimpleNode root = jvm.Program();
      root.dump("");

      //System.out.println("Expression value: " + myCalc.eval(root));
    }
}

PARSER_END(Calculator)

SKIP : {
  " " | "\r" | "\t"
}

// Keywords

TOKEN: {
	| < TRUE: "true" >
	| < FALSE: "false" >
	| < THIS : "this" >
	| < NEW : "new" >
	| < INT: "int" >
	| < IMPORT: "import" >
	| < CLASS: "class" >
	| < EXTENDS: "extends" >
	| < IF: "if" >
	| < VOID: "void" >
	| < ELSE: "else" >
	| < LENGTH: "length" >
	| < MAIN: "main" >
	| < WHILE: "while" >
	| < PUBLIC: "public" >
	| < STATIC: "static" >
	| < STRING: "String" >
	| < RETURN: "return" >
	| < BOOLEAN: "boolean" >

}

// Separators

TOKEN: {
  < COL: "," >
  | < SEMICOL: ";" >
  | < DOT: "." >
  | < LBRACE: "{" >
  | < RBRACE: "}" >
  | < LPAR: "(" >
  | < RPAR: ")" >
  | < LBRACK: "[" >
  | < RBRACK: "]" >
}

// Operations
TOKEN: {
  < AND: "&&" >
  | < OR: "||" >
  | < LESS: "<" >
  | < PLUS: "+" >
  | < MINUS: "-" >
  | < MULT: "*" >
  | < DIV: "/" >
  | < EQ: "=" >
}

TOKEN : {
  < DIGIT: ["0"-"9"] >
  < INTEGER: "0" | ["1"-"9"] (<DIGIT>)* >
  | < LF: "\n" >
  | < INTARRAY: "int[]" >
  | < STRINGARRAY: "String[]" >
  | < NOT: "!" >
  | < VAR: ["A"-"Z","a"-"z","$"](["0"-"9","A"-"Z","a"-"z","_"])* >
}

SimpleNode Program(): {}
{
    ImportDeclaration() ClassDeclaration() <EOF> { return jjtThis; }
}

void ImportDeclaration(): {}
{
    (
        <IMPORT> Identifier()
        (
            <DOT> Identifier()
        )*
        <SEMICOL>
    )*
}

void ClassDeclaration(): {}
{
    <CLASS> Identifier()
    [
        <EXTENDS> Identifier()
    ]
    <LBRACE>
    (VarDeclaration())*
    (MethodDeclaration())*
    <RBRACE>
}

void VarDeclaration(): {}
{
    Type() Identifier() <SEMICOL>
}

void MethodDeclaration(): {}
{
    <PUBLIC>
    (
        Type() Identifier()
        <LPAR>
        [
            Type() Identifier()
            (
                <COL> Type() Identifier()
            )*
        ]
        <RPAR>

        <LBRACE>
        (LOOKAHEAD(2) VarDeclaration())*
        (LOOKAHEAD(2) Statement())*
        <RETURN> Expression() <SEMICOL>
        <RBRACE>
    )
    |
    (
        <STATIC> <VOID> <MAIN>
        <LPAR>
        <STRINGARRAY>
        Identifier()
        <RPAR>

        <LBRACE>
        (LOOKAHEAD(2) VarDeclaration())*
        (LOOKAHEAD(2) Statement())*
        <RBRACE>
    )
}

void Type(): {}
{
    <INTARRAY>
    | <BOOLEAN>
    | <INT>
    | Identifier()
}

void Statement(): {}
{
    (
        <LBRACE>
        (Statement())*
        <RBRACE>
    )
    |
    (   <IF> <LPAR> Expression() <RPAR> Statement()
        <ELSE> Statement()
    )
    |
    (
        <WHILE> <LPAR> Expression() <RPAR>
        Statement()
    )
    |
    (Expression() <SEMICOL>)
    |
    (Identifier()
        (
            (<EQ> Expression() <SEMICOL>)
            |
            (<LBRACK> Expression() <RBRACK> <EQ> Expression() <SEMICOL>)
        )
    )
}

void Expression() #void: {}
{
    And()
}

void And() #void: {}
{
    Less() (LOOKAHEAD(2) <AND> Less() #And(2))*
}

void Less() #void: {} 
{
	Plus() (LOOKAHEAD(2) <LESS> Plus() #Less(2))*
}

void Sum() #void: {} 
{
	Minus() (LOOKAHEAD(2) <PLUS> Minus() #Plus(2))*
}

void Minus() #void: {} 
{
	Mult() (LOOKAHEAD(2) <MINUS> Mult() #Minus(2))*
}

void Mult() #void: {}
{
	Div() (LOOKAHEAD(2) <MULT> Div() #Mult(2))*
}

void Div() #void: {}
{
    Rest() (LOOKAHEAD(2) <MULT> Rest() #Mult(2))*
}

void Rest() #void: {}
{

    (
        ExprAnd()
        |
        ( (<LBRACK> Expression() <RBRACK>) )
        |
        (
            <DOT>
            (
                <LENGTH>
                |
                (
                    Identifier() <LPAR>
                    [
                        Expression()
                        (<COL> Expression())*
                    ]
                    <RPAR>
                )
            )
        )
    )
    | Terminal()
}

void Terminal()
{
	(
        IntegerLiteral()
        |
        <TRUE>
        |
        <FALSE>
        |
        Identifier()
        |
        <THIS>
        |
        <NEW>
        (
            (<INT> <LBRACK> Expression() <RBRACK>)
            |
            (Identifier() <LPAR> <RPAR>)
        )
        |
        (<NOT> Expression())
        |
        (<LPAR> Expression() <RPAR> )
    )
}

void Identifier(): {}
{
    <VAR>
}

void IntegerLiteral(): {}
{
    <INTEGER>
}