options {
    LOOKAHEAD = 1;
}

PARSER_BEGIN(Parser)

import java.util.HashMap;
import java.io.*;

public class Parser {
    static int errors = 0;

    public static HashMap<String, Integer> symbols = new HashMap<String, Integer>();

    public static void main(String[] args) throws ParseException {
      if (args.length != 1) {
        System.out.println("Usage: java Calculator input.jmm");
        return;
      }
      FileInputStream file;
      try {
        file = new FileInputStream(args[0]);
      } catch (Exception e) {
        System.err.println("File " + args[0] + " not found");
			  return;
      }

      Parser jvm = new Parser(file);
      SimpleNode root = jvm.Program();

      System.out.println("If you see this, probably its working!");

      root.dump("");

    }
}

PARSER_END(Parser)

SKIP : {
  " "
  | "\r"
  | "\t"
  | "\n"
}

// Keywords

TOKEN: {
    < TRUE: "true" >
	| < FALSE: "false" >
	| < THIS : "this" >
	| < NEW : "new" >
	| < INT: "int" >
	| < IMPORT: "import" >
	| < CLASS: "class" >
	| < EXTENDS: "extends" >
	| < IF: "if" >
	| < VOID: "void" >
	| < ELSE: "else" >
	| < LENGTH: "length" >
	| < MAIN: "main" >
	| < WHILE: "while" >
	| < PUBLIC: "public" >
	| < STATIC: "static" >
	| < RETURN: "return" >
	| < BOOLEAN: "boolean" >
}

// Separators

TOKEN: {
  < COL: "," >
  | < SEMICOL: ";" >
  | < DOT: "." >
  | < LBRACE: "{" >
  | < RBRACE: "}" >
  | < LPAR: "(" >
  | < RPAR: ")" >
  | < LBRACK: "[" >
  | < RBRACK: "]" >
}

// Operations
TOKEN: {
  < AND: "&&" >
  | < OR: "||" >
  | < LESS: "<" >
  | < PLUS: "+" >
  | < MINUS: "-" >
  | < MULT: "*" >
  | < DIV: "/" >
  | < EQ: "=" >
}

TOKEN : {
  < INTEGER_LITERAL: (["0"-"9"])+ >
  | < INTARRAY: "int[]" >
  | < STRINGARRAY: "String[]" >
  | < NOT: "!" >
  | < IDENTIFIER: ["A"-"Z","a"-"z","$","_"](["0"-"9","A"-"Z","a"-"z","_"])* >
}


JAVACODE
void error_skipto(int kind) {
  errors++;
  if (errors == 10) { // "The compiler could report the first 10 errors found before aborting execution"
    System.out.println("10 errors found");
    System.exit(1);
  }
  ParseException e = generateParseException();  // generate the exception object.
  System.out.println("#" + errors + ": Error in while Statement:\n" + e.toString());  // print the error message
  Token t;
  do {
    t = getNextToken();
  } while (t.kind != kind);
    // The above loop consumes tokens all the way up to a token of
    // "kind".  We use a do-while loop rather than a while because the
    // current token is the one immediately before the erroneous token
    // (in our case the token immediately before what should have been
    // "if"/"while".
}


SimpleNode Program(): {} 
{
    ImportDeclaration() ClassDeclaration() <EOF> { return jjtThis; }
}

void ImportDeclaration() #void: { Token t; }
{
	try {
		(
			<IMPORT> <IDENTIFIER>
			(
				<DOT> <IDENTIFIER> 
			)*
			<SEMICOL>
		)* #IMPORT
	} catch (Exception e) {
		System.out.println("Expected Import Declaration\n" + e);
		System.exit(1);
	}
}

void ClassDeclaration(): { Token t1; }
{
    try {
        <CLASS> t1 = <IDENTIFIER> { jjtThis.name = t1.image; } #ID
        [
            <EXTENDS> <IDENTIFIER>
        ]
        <LBRACE>
        (VarDeclaration())* 
        (<PUBLIC> (MainDeclaration() | MethodDeclaration()))*
        <RBRACE>
    } catch (Exception e) {
        System.out.println("Expected Class Declaration\n" + e);
		System.exit(1);
    }
    
}

void VarDeclaration() #void: {}
{
    try {
        Type() <IDENTIFIER> <SEMICOL>
    } catch (Exception e) {
		System.out.println("Expected Var Declaration\n" + e);
		System.exit(1);    
    }
}

void MethodDeclaration() #void: {}
{
	try {
        Type() <IDENTIFIER>
        <LPAR>
        [
            Type() <IDENTIFIER>
            (
                <COL> Type() <IDENTIFIER>
            )*
        ]
        <RPAR>

        <LBRACE>
        (LOOKAHEAD(2) VarDeclaration())*
        (LOOKAHEAD(2) Statement())*
        <RETURN> Expression() <SEMICOL>
        <RBRACE> 
    } catch (Exception e) {
		System.out.println("Expected Method Declaration\n" + e);
		System.exit(1);
    }
    
}

void MainDeclaration() #void: {}
{
    try {
        <STATIC> <VOID> <MAIN>
        <LPAR>
        <STRINGARRAY>
        <IDENTIFIER>
        <RPAR>

        <LBRACE>
        (LOOKAHEAD(2) VarDeclaration())* // VarDeclaration gives Type, which can be Identifier
        (LOOKAHEAD(2) Statement())*
        <RBRACE>
    } catch (Exception e) {
		System.out.println("Expected Main Declaration\n" + e);
		System.exit(1);
    }
    
}


void Type() #void: {}
{
    try {
        <INTARRAY>
        | <BOOLEAN>
        | <INT>
        | <IDENTIFIER>
    } catch (Exception e) {
        System.out.println("Expected Type\n" + e);
        System.exit(1);
    }
    
}

void Statement() #void: {}
{

    try {
        <LBRACE>
        (Statement())*
        <RBRACE>
        |
        <IF> <LPAR> Expression() <RPAR> Statement()
        <ELSE> Statement()
        |
        try { <WHILE> <LPAR> Expression() <RPAR> }
        catch(ParseException e) {
          error_skipto(RPAR);
        }
        Statement()
        |
        LOOKAHEAD(2) <IDENTIFIER> <EQ> Expression() <SEMICOL>
        |
        LOOKAHEAD(2) <IDENTIFIER> <LBRACK> Expression() <RBRACK> <EQ> Expression() <SEMICOL>
        |
        Expression() <SEMICOL>     
    } catch (Exception e) {
		System.out.println("Expected Statement\n" + e);
		System.exit(1);
    }
    
}

void Expression() #void: {}
{
    try {
        And()
    } catch (Exception e) {
		System.out.println("Expected Expression\n" + e);
		System.exit(1);
    }
    
}

void And() #void: {}
{
    try {
        Less() (LOOKAHEAD(2) <AND> Less() #And(2))*
    } catch (Exception e) {
		System.out.println("Expected AND\n" + e);
		System.exit(1);
    }

}

void Less() #void: {}
{
	try {
        Plus() (LOOKAHEAD(2) <LESS> Plus() #Less(2))*
    } catch (Exception e) {
		System.out.println("Expected LESS\n" + e);
		System.exit(1);
    }
}

void Plus() #void: {}
{
	try {
        Minus() (LOOKAHEAD(2) <PLUS> Minus() #Plus(2))*
    } catch (Exception e) {
		System.out.println("Expected PLUS\n" + e);
		System.exit(1);
    }
}

void Minus() #void: {}
{
	try {
        Mult() (LOOKAHEAD(2) <MINUS> Mult() #Minus(2))*
    } catch (Exception e) {
		System.out.println("Expected MINUS\n" + e);
		System.exit(1);
    }
}

void Mult() #void: {}
{
    try {       
        Div() (LOOKAHEAD(2) <MULT> Div() #Mult(2))*
    } catch (Exception e) {
        System.out.println("Expected MULT\n" + e);
		System.exit(1);
    }
	
}

void Div() #void: {}
{
    try {
        Rest() (LOOKAHEAD(2) <DIV> Rest() #Mult(2))*
    } catch (Exception e) {
		System.out.println("Expected DIV\n" + e);
		System.exit(1);
    }
}

void Rest() #void: {}
{
    try {
        <INTEGER_LITERAL> Terminal()
        |
        <TRUE> Terminal()
        |
        <FALSE> Terminal()
        |
        <IDENTIFIER> Terminal()
        |
        <THIS> Terminal()
        |
        <NEW> 
        (
            (<INT> <LBRACK> Expression() <RBRACK> Terminal())
            |
            (<IDENTIFIER> <LPAR> <RPAR> Terminal())
        )
        |
        <NOT> Expression() Terminal()
        |
        <LPAR> Expression() <RPAR> Terminal()
        
    } catch (Exception e) {
		System.out.println("Expected REST\n" + e);
		System.exit(1);
    }
}

void Terminal() #void: {}
{
    try {
        <LBRACK> Expression() <RBRACK> Terminal()
        |
        <DOT>
        (
            (
                <LENGTH> Terminal() 
            )
            |
            (
                <IDENTIFIER> <LPAR>
                [
                    Expression()
                    (<COL> Expression())*
                ]
                <RPAR>
                Terminal()
            )
        )
        |
        {} // Why does [ ] not do the job?
        
    } catch (Exception e) {
		System.out.println("Expected Terminal\n" + e);
		System.exit(1);
    }
    
}