options {
    LOOKAHEAD = 1;
}

PARSER_BEGIN(Parser)

import java.util.ArrayList;
import java.util.HashMap;
import java.io.*;
import pt.up.fe.comp.jmm.report.*;

public class Parser {
    private ArrayList<Report> reports = new ArrayList<Report>();
    public ArrayList<Report> getReports() { return reports; }

    public static void main(String[] args) {}
}

PARSER_END(Parser)

SKIP : {
  " "
  | "\r"
  | "\t"
  | "\n"
}

// Keywords
TOKEN: {
    < TRUE: "true" >
	| < FALSE: "false" >
	| < THIS : "this" >
	| < NEW : "new" >
	| < INT: "int" >
	| < IMPORT: "import" >
	| < CLASS: "class" >
	| < EXTENDS: "extends" >
	| < IF: "if" >
	| < VOID: "void" >
	| < ELSE: "else" >
	| < LENGTH: "length" >
	| < MAIN: "main" >
	| < WHILE: "while" >
	| < PUBLIC: "public" >
	| < STATIC: "static" >
	| < RETURN: "return" >
	| < BOOLEAN: "boolean" >
}

// Separators
TOKEN: {
  < COL: "," >
  | < SEMICOL: ";" >
  | < DOT: "." >
  | < LBRACE: "{" >
  | < RBRACE: "}" >
  | < LPAR: "(" >
  | < RPAR: ")" >
  | < LBRACK: "[" >
  | < RBRACK: "]" >
}

// Operations
TOKEN: {
  < AND: "&&" >
  | < OR: "||" >
  | < LESS: "<" >
  | < PLUS: "+" >
  | < MINUS: "-" >
  | < MULT: "*" >
  | < DIV: "/" >
  | < EQ: "=" >
}

TOKEN : {
  < INTEGER_LITERAL: (["0"-"9"])+ >
  | < INTARRAY: "int[]" >
  | < STRINGARRAY: "String[]" >
  | < NOT: "!" >
  | < IDENTIFIER: ["A"-"Z","a"-"z","$","_"](["0"-"9","A"-"Z","a"-"z","_"])* >
}


JAVACODE
void error_skipto(int kind) {
  if (reports.size() == 10) { // "The compiler could report the first 10 errors found before aborting execution"
    System.out.println("10 errors found");
    return;
  }
  Token t;
  do {
    t = getNextToken();
  } while (t.kind != kind && t.kind != 0); // Treaing reaching EOF
    // The above loop consumes tokens all the way up to a token of
    // "kind".  We use a do-while loop rather than a while because the
    // current token is the one immediately before the erroneous token
    // (in our case the token immediately before what should have been
    // "if"/"while".
}


SimpleNode Program(): {} 
{
    try {
        ImportDeclaration() ClassDeclaration() <EOF>
    }
    catch (ParseException e) {
        Report r = new Report(ReportType.ERROR, Stage.SYNTATIC, token.beginLine, e.getMessage());
        reports.add(r);
        System.out.println("Program Exception");
    }
    { return jjtThis; }
}

void ImportDeclaration(): { Token t; String s = ""; }
{
    (
        <IMPORT> t=<IDENTIFIER> { s += t.image; }

        (<DOT> t=<IDENTIFIER> { s += "."+t.image; } )*
        <SEMICOL> { jjtThis.name = t.image; jjtThis.put("qualifiedName", s); }
    )*
}

/*
void ImportDeclaration(): { Token t; }
{
    (
        <IMPORT> t=<IDENTIFIER> { jjtThis.name = t.image; }

        (<DOT> t=<IDENTIFIER> { jjtThis.name = t.image; } #ImportPart)*
        <SEMICOL>
    )*
}
*/

void ClassDeclaration(): { Token t1, t2; }
{
    <CLASS> t1=<IDENTIFIER> { jjtThis.name = t1.image; } #Class
    [
        <EXTENDS> t2=<IDENTIFIER> {jjtThis.name = t2.image; } #Extends
    ]
    <LBRACE>
    (VarDeclaration())*
    (<PUBLIC> (MainDeclaration() | MethodDeclaration()))*
    <RBRACE>
}

void VarDeclaration() #void: {}
{
    Type() <IDENTIFIER> <SEMICOL>
}

void MethodDeclaration() #void: {}
{
    Type() <IDENTIFIER>
    <LPAR>
    [
        Type() <IDENTIFIER>
        (
            <COL> Type() <IDENTIFIER>
        )*
    ]
    <RPAR>

    <LBRACE>
    (LOOKAHEAD(2) VarDeclaration())*
    (LOOKAHEAD(2) Statement())*
    <RETURN> Expression() <SEMICOL>
    <RBRACE>
}

void MainDeclaration() #void: {}
{
    <STATIC> <VOID> <MAIN>
    <LPAR>
    <STRINGARRAY>
    <IDENTIFIER>
    <RPAR>

    <LBRACE>
    (LOOKAHEAD(2) VarDeclaration())* // VarDeclaration gives Type, which can be Identifier
    (LOOKAHEAD(2) Statement())*
    <RBRACE>
}


void Type() #void: {}
{
    <INTARRAY>
    | <BOOLEAN>
    | <INT>
    | <IDENTIFIER>
}

void Statement() #void: {}
{
    <LBRACE>
    (Statement())*
    <RBRACE>
    |
    <IF> <LPAR> Expression() <RPAR> Statement()
    <ELSE> Statement()
    |
    try { <WHILE> <LPAR> Expression() <RPAR> }
    catch(ParseException e) {
      Report r = new Report(ReportType.ERROR, Stage.SYNTATIC, token.beginLine, e.getMessage());
      reports.add(r);
      error_skipto(RPAR);
    }
    Statement()
    |
    LOOKAHEAD(2) <IDENTIFIER> <EQ> Expression() <SEMICOL>
    |
    LOOKAHEAD(2) <IDENTIFIER> <LBRACK> Expression() <RBRACK> <EQ> Expression() <SEMICOL>
    |
    Expression() <SEMICOL>
}

void Expression() #void: {}
{
    And()
}

void And() #void: {}
{
    Less() (LOOKAHEAD(2) <AND> Less() #And(2))*
}

void Less() #void: {}
{
    Plus() (LOOKAHEAD(2) <LESS> Plus() #Less(2))*
}

void Plus() #void: {}
{
    Minus() (LOOKAHEAD(2) <PLUS> Minus() #Plus(2))*
}

void Minus() #void: {}
{
    Mult() (LOOKAHEAD(2) <MINUS> Mult() #Minus(2))*
}

void Mult() #void: {}
{
    Div() (LOOKAHEAD(2) <MULT> Div() #Mult(2))*
}

void Div() #void: {}
{
    Rest() (LOOKAHEAD(2) <DIV> Rest() #Div(2))*
}

void Rest() #void: {}
{
    <INTEGER_LITERAL> Terminal()
    |
    <TRUE> Terminal()
    |
    <FALSE> Terminal()
    |
    <IDENTIFIER> Terminal()
    |
    <THIS> Terminal()
    |
    <NEW>
    (
        (<INT> <LBRACK> Expression() <RBRACK> Terminal())
        |
        (<IDENTIFIER> <LPAR> <RPAR> Terminal())
    )
    |
    <NOT> Expression() Terminal()
    |
    <LPAR> Expression() <RPAR> Terminal()
}

void Terminal(): {}
{
    <LBRACK> Expression() <RBRACK> Terminal()
    |
    <DOT>
    (
        (
            <LENGTH> Terminal()
        )
        |
        (
            <IDENTIFIER> <LPAR>
            [
                Expression()
                (<COL> Expression())*
            ]
            <RPAR>
            Terminal()
        )
    )
    |
    {} // Why does [ ] not do the job?
}